# 从零开始的辅助创作工作流 (Create Workflow)


本文档基于 `doc/design/CREATE_DESIGN.md` 中定义的设计思想，详细描述了用户在 SailZen 中从零开始进行小说创作的典型工作流程。它旨在明确前端需要提供的功能、用户界面的交互方式，以及后端需要支持的服务。

此工作流的核心是**世界观与正文的并行构建**，分为四个主要阶段：
1.  **世界观构思（World Conception）**：在动笔写作前，搭建世界的核心框架。
2.  **情节与人物骨架（Scaffolding）**：规划故事走向和主要角色的发展路径。
3.  **手稿撰写（Manuscript Writing）**：在世界观的指导下撰写小说正文，并建立内容与知识的链接。
4.  **迭代与重构（Iteration & Refactoring）**：在创作过程中灵活地修改设定和情节，并保持内容一致性。

---

## 2. 阶段一：世界观构思 (The Blank Canvas)

这个阶段，用户还没有开始写任何章节，专注于纯粹的设定和创意。

### 2.1 用户工作流

1.  **创建作品**：用户在 SailZen 中创建一个新的 `Work`，例如“赛博朋克西游记”。
2.  **打开世界视图**：VSCode 插件提供一个专门的 “世界视图” (World View) 面板。此视图是本阶段的主要工作区。
3.  **创建核心设定**：
    - 用户在世界视图中，使用模板或自由形式创建核心 `Concept` 实体。例如，创建一个名为“义体协议”的 `lore_entry` 实体，并在其描述中用 Markdown 详细说明其规则。
    - **LLM 辅助**：用户可以请求 LLM 进行头脑风暴，例如输入“为‘义体协议’生成三个有趣的副作用”，LLM 返回的点子可以被一键采纳为设定的属性。
4.  **定义主要阵营与地点**：
    - 用户创建 `Organization` 类型的实体，如“花果山集团”、“天庭网络安全局”。
    - 用户创建 `Location` 类型的实体，如“南天门数据中心”。
    - 实体之间可以立即建立关系，例如，“花果山集团”与“天庭网络安全局”的关系是 `conflict`。此时这些关系不依赖任何文本证据。

### 2.2 所需功能支持

-   **VSCode 插件 (Frontend)**:
    -   一个非线性的、可视化的“世界视图”面板，可能采用脑图（Mind Map）或看板（Kanban）形式。
    -   为不同类型的实体（`lore_entry`, `organization`, `location`）提供结构化的编辑器。
    -   在UI中集成“LLM Brainstorm”按钮。
    -   允许用户在没有 `text_span` 的情况下创建实体关系。
-   **后端 (Backend)**:
    -   支持在 `Work` 级别上对 `entities` 和 `entity_relations` 进行 CRUD 操作的 API。
    -   为 LLM Brainstorming 提供专用的 `llm_service` 端点。

---

## 3. 阶段二：情节与人物骨架 (Scaffolding)

在核心世界观建立后，作者开始规划故事的宏观结构。

### 2.1 用户工作流

1.  **创建主角**：用户在世界视图中创建 `Character` 实体，如“孙悟空”，并填写其核心设定（如 `title: '首席安全官'`, `goal: '寻找数字蟠桃'`）。
2.  **规划故事主线**：
    - 用户切换到“情节线”(Plotline) 或“时间轴”(Timeline) 视图。
    - 用户创建一系列核心的 `narrative_events`，例如：“事件1: 悟空大闹天宫服务器”，“事件2: 被压在五指山防火墙下”，“事件3: 遇见三藏路由器”。
    - 这些事件可以通过拖拽排序，并建立父子关系（如“大闹天宫”包含多个子事件）。
3.  **定义人物弧光**：
    - 用户创建一个 `knowledge_collection`，类型为 `character_arc`，命名为“悟空的救赎之路”。
    - 用户将“悟空”实体和上述一系列关键事件拖入这个集合中，并为每个事件标注其在弧光中的角色（如“ inciting_incident”, “climax”）。

### 2.2 所需功能支持

-   **VSCode 插件 (Frontend)**:
    -   一个时间轴或序列图的 Webview UI，用于可视化和编辑 `narrative_events`。
    -   支持拖拽 `entities` 到事件中，以建立 `event_participants` 关联。
    -   一个集合编辑器，允许用户创建 `character_arc` 等自定义分组，并将任意知识项（实体、事件）拖入其中。
-   **后端 (Backend)**:
    -   支持对 `narrative_events` 的层级和顺序进行管理的 API。
    -   支持 `knowledge_collections` 模型 CRUD 的 API。

---

## 4. 阶段三：手稿撰写 (Manuscript Writing)

用户开始正式撰写小说章节，将脑海中的世界观和情节落实为文字。

### 2.1 用户工作流

1.  **创建初稿**：用户为作品创建一个新的 `Edition`，例如“第一版草稿”。
2.  **开始写作**：
    - VSCode 插件的章节树将显示出来，用户可以创建第一个 `document_node`（例如，“第一章.md”）。
    - 写作界面是标准的 Markdown 编辑器，但侧边栏的世界视图、情节视图处于激活状态。
3.  **链接知识与文本**：
    - 当用户写到“那个被称为‘齐天大圣’的黑客...”时，他可以选中“齐天大圣”，右键菜单选择“链接到实体...”，然后在弹出的搜索框中选择已创建的“孙悟空”实体。这将在后台创建一个 `entity_mention`。
    - 或者，用户可以直接从世界视图中将“孙悟空”实体拖拽到编辑器中的指定位置，自动完成链接。
4.  **LLM 协同写作**：
    - 用户写完一个段落后，可以按下一个快捷键，触发 LLM 续写。
    - **上下文感知**：LLM 的续写请求会自动携带当前章节的上下文、相关的角色设定（孙悟空的性格、目标）和即将发生的情节（来自情节线视图），从而生成高度相关且符合设定的内容。
    - 生成的内容会以 Diff 视图呈现，用户可以选择性地接受。

### 2.2 所需功能支持

-   **VSCode 插件 (Frontend)**:
    -   实现 `EDITOR_PRD.md` 中描述的本地文件同步机制，将 `document_nodes` 映射为本地 `.md` 文件。
    -   编辑器右键菜单和拖拽功能，用于创建 `entity_mention`。
    -   “从文本创建实体”的功能，允许用户在写作时即时添加新的人物或概念。
    -   与 LLM 交互的内联 UI（类似 Github Copilot 的幽灵文本或 Diff 视图）。
-   **后端 (Backend)**:
    -   用于创建 `entity_mention` 并将其与 `text_span` 关联的 API。
    -   `llm_service` 需要一个能聚合多种上下文（文本、实体、情节）来生成高质量续写的复杂端点。

---

## 5. 阶段四：迭代与重构 (Iteration & Refactoring)

创作过程充满了变化。这个阶段处理的是当核心设定或情节发生改变时，如何维护整个故事的一致性。

### 2.1 用户工作流

1.  **修改核心设定**：在小说写到一半时，作者决定“孙悟空”的目标不再是“寻找数字蟠桃”，而是“摧毁轮回算法”。他直接在世界视图中编辑“孙悟空”这个 `Entity` 的 `goal` 属性。
2.  **触发一致性分析**：
    - 这个修改被记录在一个 `ChangeSet` 中。用户可以手动或系统自动触发一次“影响分析”。
    - 系统分析显示：这个变更与 3 个已写好的 `narrative_events` 和 15 个文本段落 (`entity_mentions`) 的上下文高度相关，可能存在不一致。
3.  **智能重构**：
    - VSCode 插件在文件浏览器和编辑器边栏中高亮所有受影响的章节和段落。
    - 用户逐一检查这些地方。对于每一处，他可以：
        a. **手动修改**：直接重写文本。
        b. **请求 LLM 重构**：点击一个按钮，请求 LLM“根据孙悟空的新目标，重写这个段落”。LLM 将在保持原意图的基础上，调整措辞和动机描述。
4.  **提交变更**：所有相关的文本和设定修改都完成后，用户将这个大的 `ChangeSet` 提交，完成一次重构。

### 2.2 所需功能支持

-   **VSCode 插件 (Frontend)**:
    -   提供一个“影响分析”或“一致性检查”的可视化界面，列出所有受影响的条目。
    -   在编辑器中提供基于诊断（Diagnostics）的高亮和快速修复（Quick Fix）功能，例如 "Refactor with LLM"。
-   **后端 (Backend)**:
    -   一个强大的**一致性检查服务**。当接收到一个 `ChangeSet` 时，能找出所有相关的知识条目和文本节点。这可能需要借助向量检索（查找语义相关的文本）和知识图谱遍历（查找关联的实体和事件）。
    -   为 LLM Refactoring 提供专用的 `llm_service` 端点，该端点需要理解“旧上下文”、“新目标”和“待修改文本”三者之间的关系。

---

## 6. 功能清单总结

-   **世界视图 (World View)**
    -   [ ] 可视化实体编辑器 (脑图/看板)
    -   [ ] 结构化实体编辑器 (按类型区分)
    -   [ ] 无文本实体关系创建
-   **情节/时间轴视图 (Plotline View)**
    -   [ ] 可视化事件编辑器 (时间轴/序列图)
    -   [ ] 事件层级与排序
    -   [ ] 人物弧光/集合编辑器
-   **编辑器集成 (Editor Integration)**
    -   [ ] `document_node` 到本地文件的同步
    -   [ ] 从文本链接/创建实体的功能 (右键菜单/拖拽)
    -   [ ] 上下文感知的 LLM 协同写作 (续写/润色)
-   **重构与一致性 (Refactoring & Consistency)**
    -   [ ] 基于 `ChangeSet` 的影响分析功能
    -   [ ] 编辑器内不一致性高亮与诊断
    -   [ ] LLM 辅助重构的快速修复功能
-   **LLM 服务 (LLM Services)**
    -   [ ] `brainstorm`: 创意生成
    -   [ ] `elaborate`: 内容扩写
    -   [ ] `continue`: 上下文感知续写
    -   [ ] `refactor`: 基于目标变更的文本重构
    -   [ ] `consistency_check`: 检查逻辑矛盾
-   **异步创作任务系统 (Async Creation Tasks)**
    -   [ ] 创建并管理多种类型的创作任务
    -   [ ] 任务队列与后台处理
    -   [ ] 多LLM并行处理与结果对比
    -   [ ] 任务进度跟踪与状态管理
    -   [ ] 创作分支管理与结果合入

---

## 7. 阶段五：智能创作任务系统 (Intelligent Creation Tasks)

在完成了基础的写作和重构工作流后，作者往往需要更强大的LLM辅助能力。这个阶段提供了一个异步的、可并行的、支持多模型协同的创作任务系统。

### 7.1 核心概念

**创作任务 (Creation Task)** 是一个可以提交到后台队列、由LLM异步处理的结构化请求。与即时的续写不同，创作任务具有以下特点：

-   **异步执行**：任务提交后在后台运行，用户可以继续其他工作
-   **上下文丰富**：自动收集相关的世界观、情节、角色等上下文信息
-   **多模型并行**：可同时向多个LLM（如GPT-4, Claude, Gemini）提交相同任务，获得不同创作方向
-   **结果对比**：以分支形式呈现不同LLM的创作结果，支持对比和选择性合入
-   **可配置范围**：精细控制联想范围，如仅使用特定章节、特定角色、特定情节线的信息

### 7.2 任务类型

#### 7.2.1 完善任务 (Refinement Task)

**使用场景**：用户已经创建了一些核心的实体（人物、组织、地点等）和梗概，但希望让LLM帮助完善细节。

**用户工作流**：

1.  **选择实体**：在世界视图中，用户选中一个或多个实体，例如选中"孙悟空"角色。
2.  **创建完善任务**：
    -   右键菜单选择"创建完善任务..."
    -   在弹出的任务配置面板中：
        -   **任务名称**：例如"完善孙悟空的背景故事"
        -   **任务目标**：可选择预定义模板（"扩展角色背景"、"生成角色对话风格示例"、"创建角色关系网"）或自定义描述
        -   **联想范围**：
            -   全局：使用整个作品的所有信息
            -   限定实体：仅使用与选中实体直接相关的其他实体和关系
            -   限定集合：仅使用特定的 `knowledge_collection`（如"第一卷世界观"）
        -   **输出格式**：结构化数据（JSON）、Markdown文本、或直接更新实体属性
3.  **选择LLM提供商**：
    -   可以选择单个模型，或勾选多个（如同时使用 GPT-4 和 Claude-3.5）
    -   为不同模型设置不同的参数（temperature、max_tokens等）
4.  **提交任务**：任务提交到后台队列，状态变为 `pending`

#### 7.2.2 完整写作任务 (Complete Writing Task)

**使用场景**：用户已经有了部分手稿或章节大纲，希望LLM基于现有内容完成一个完整的章节或段落。

**用户工作流**：

1.  **定位写作点**：
    -   在编辑器中，用户可以在某个章节末尾或中间插入一个特殊标记 `[WRITE_TASK:description]`，例如 `[WRITE_TASK:描写悟空与牛魔王的决战场景]`
    -   或者在章节树中右键某个节点，选择"创建写作任务..."
2.  **配置写作任务**：
    -   **任务名称**：例如"第三章：天宫决战"
    -   **写作指令**：详细的创作需求，如"写一个3000字的打斗场景，要体现悟空的狂放和牛魔王的沉稳，最后以悟空险胜结束"
    -   **联想范围**：
        -   当前章节：仅使用本章节已写内容作为上下文
        -   当前卷：使用本卷所有已写内容
        -   相关情节线：使用特定 `knowledge_collection` 中的事件和角色
        -   自定义：手动选择要包含的章节、实体、事件
    -   **长度控制**：目标字数或段落数
    -   **风格参考**：可以指定已有章节作为风格参照
3.  **多方向创作**：
    -   用户可以为不同LLM设置不同的创作方向，例如：
        -   GPT-4：「重点描写心理活动，悲剧性结局」
        -   Claude：「重点描写动作场面，开放式结局」
        -   Gemini：「加入幽默元素，意外转折」
4.  **提交并追踪**：任务进入队列，用户可以在"任务面板"中查看所有任务的实时进度

### 7.3 任务执行与结果管理

#### 7.3.1 后台处理流程

1.  **任务入队**：用户提交的任务首先保存到数据库的 `creation_tasks` 表，状态为 `pending`
2.  **上下文收集**：
    -   后台服务根据任务的"联想范围"配置，从数据库中收集相关信息：
        -   相关的 `entities` 及其属性和关系
        -   相关的 `narrative_events` 及其顺序和层级
        -   相关的 `document_nodes` 的文本内容
        -   相关的 `entity_mentions` 来理解哪些实体在哪些文本中被提及
    -   将这些信息组织成结构化的上下文 Prompt
3.  **多模型调度**：
    -   如果用户选择了多个LLM，系统会为每个LLM创建一个 `task_execution` 子任务
    -   每个子任务包含：模型名称、提示词、参数、状态
    -   调度器并行调用不同的LLM API
4.  **流式结果存储**：
    -   LLM返回的结果（可能很长）实时保存到 `task_results` 表
    -   每个结果关联到一个 `task_execution`，并记录生成的token数、耗时等元数据
5.  **完成通知**：所有子任务完成后，父任务状态变为 `completed`，VSCode插件收到通知并弹出提醒

#### 7.3.2 结果查看与对比

1.  **任务面板**：
    -   VSCode插件提供一个专门的"创作任务"面板，显示所有任务的列表
    -   每个任务显示：名称、类型、状态（pending/running/completed/failed）、创建时间、关联的实体/章节
2.  **打开结果**：
    -   点击已完成的任务，打开一个"多分支对比视图"
    -   如果任务只提交给了一个LLM，直接显示其结果
    -   如果任务提交给了多个LLM，界面分屏显示：
        -   左侧：原始内容（如果是完善任务，显示原实体内容；如果是写作任务，显示已有的章节内容）
        -   中间：GPT-4 的结果
        -   右侧：Claude 的结果
        -   可以切换查看更多模型的结果
3.  **分支导航**：
    -   每个LLM的结果被视为一个"创作分支"
    -   用户可以为分支添加标签和备注，如"这个版本更符合角色性格"

#### 7.3.3 结果合入

1.  **选择性合入**：
    -   **完善任务**：
        -   如果任务是完善某个实体，用户可以逐字段对比不同LLM生成的属性值
        -   勾选要采纳的字段，点击"应用到实体"
        -   系统会创建一个 `ChangeSet` 记录这次修改
    -   **写作任务**：
        -   如果任务是生成一段文本，用户可以：
            a. **直接采纳**：选择一个分支，点击"插入到文档"，该结果会被插入到 `document_node` 的目标位置
            b. **混合编辑**：打开一个特殊的编辑器，允许用户从不同分支中拷贝段落，手动组合成最终版本
            c. **重新生成**：如果所有结果都不满意，可以调整参数后重新提交任务
2.  **创建新版本**：
    -   合入时可以选择：
        -   覆盖当前 `Edition`：直接修改现有文档
        -   创建新 `Edition`：保留原文档，在新版本中应用修改（推荐用于大幅改动）
3.  **记录来源**：
    -   合入的内容会在元数据中记录其来源（哪个任务、哪个LLM、何时生成）
    -   这有助于后续的溯源和版本管理

### 7.4 高级场景：多方向情节分叉

**场景**：作者在某个关键情节点犹豫不决，希望探索多种可能的发展方向。

**工作流**：

1.  **定义分叉点**：在"第十章：悟空面对选择"的末尾，用户创建一个"完整写作任务"
2.  **设置多个创作方向**：
    -   方向A（GPT-4）："悟空选择牺牲自己，拯救三藏"
    -   方向B（Claude）："悟空选择背叛三藏，加入天庭"
    -   方向C（Gemini）："悟空找到第三条路，调和矛盾"
3.  **并行生成**：三个LLM同时生成后续3000字的内容
4.  **读者测试**：作者可以将三个分支分别发给beta读者，收集反馈
5.  **选择主线**：根据反馈和个人偏好，作者选择方向B作为正式剧情，将其合入主Edition
6.  **保留分支**：方向A和C作为"番外篇"或"平行宇宙"保存在独立的 `Edition` 中

### 7.5 所需功能支持

-   **VSCode 插件 (Frontend)**:
    -   创作任务配置面板（支持复杂的UI交互）
    -   任务列表与进度追踪面板
    -   多分支对比视图（可能需要自定义 Webview）
    -   结果合入的交互式编辑器
-   **后端 (Backend)**:
    -   `creation_tasks` 表及其相关模型和服务
    -   任务队列管理器（可使用Celery或内置的异步任务系统）
    -   智能上下文收集器（`ContextCollectorService`）
    -   多LLM调度器（`MultiLLMOrchestrator`）
    -   结果存储与检索 API

### 7.6 功能清单

-   **任务创建与配置**
    -   [ ] 完善任务创建界面
    -   [ ] 写作任务创建界面
    -   [ ] 联想范围配置器（全局/限定实体/限定集合）
    -   [ ] 多LLM选择与参数配置
    -   [ ] 多方向创作配置（为不同LLM设置不同指令）
-   **任务执行**
    -   [ ] 任务队列管理
    -   [ ] 智能上下文收集器
    -   [ ] 多LLM并行调度
    -   [ ] 流式结果存储
    -   [ ] 实时进度推送（WebSocket）
-   **结果管理**
    -   [ ] 任务列表面板
    -   [ ] 多分支对比视图
    -   [ ] 分支标签与备注
    -   [ ] 结果评分与收藏
-   **结果合入**
    -   [ ] 实体字段选择性更新
    -   [ ] 文本插入与位置管理
    -   [ ] 混合编辑器（从多分支拷贝内容）
    -   [ ] 创建新Edition选项
    -   [ ] 来源元数据记录

